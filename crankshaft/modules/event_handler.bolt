from dataclasses import dataclass, field
from typing import Callable, ClassVar

from ./config import Config


@dataclass
class Event:
    handler: Callable = field(kw_only=True, repr=False)
    event_id: str = field(kw_only=True)

    active: bool = field(init=False, default=False)
    payload_params: list = field(init=False, default_factory=list)

    def __post_init__(self):
        local_dir = f"{Config.ROOT_LOCAL}/event_handler/builtin/{self.event_id}"
        global_dir = f"{Config.ROOT}/event_handler/builtin/{self.event_id}"

        self.handler_dir = f"{global_dir}/__handler__"
        self.payload_path = f"{local_dir}/__payload__"
        self.fork_path = f"{global_dir}/__fork__"
        self.bypass_fork_path = f"{local_dir}/__bypass_fork__"
        self.bypass_fork_tag_path = f"{global_dir}/__bypass_fork_tag__"
        self.trigger_path = f"{global_dir}/__trigger__"

    def trigger(self, *params):
        """Triggers the event on runtime."""

        self.payload_params = params
        
        execute function self.trigger_path:
            function f"#{self.bypass_fork_tag_path}"       # bypass_fork multipack compatibility
            function f"#{self.fork_path}"

    def activate(self):
        """Activates and deploys the handler into the datapack."""

        if self.active:
            return

        self.handler(self)
        self._fork_to_payload()
        self.active = True

    def path(self, subpath: str) -> str:
        """Generates a function path inside the event working directory."""

        return f"{self.handler_dir}/{subpath}"

    def attach_payload(self, payload_ref: Callable, bypass_fork=False):
        path = self.payload_path

        if bypass_fork:
            # hacky fix for multipack compatibility
            # redirects the payload making it only run once globally
            merge function_tag self.bypass_fork_tag_path {"values": [self.bypass_fork_path]}
            path = self.bypass_fork_path

        append function path:
            payload_ref(*self.payload_params)

    def _fork_to_payload(self):
        merge function_tag self.fork_path {"values": [self.payload_path]}

@dataclass
class CustomEvent:
    handler: Callable = field(kw_only=True, repr=False)

    active: bool = field(init=False, default=False)
    payload_params: list = field(init=False, default_factory=list)
    next_id: ClassVar[int] = 0

    def __post_init__(self):
        self.event_id = f"{self._get_next_id()}__{ctx.project_id}"

        local_dir = f"{Config.ROOT_LOCAL}/event_handler/custom/{self.event_id}"

        self.handler_dir = f"{local_dir}/__handler__"
        self.payload_path = f"{local_dir}/__payload__"

    def trigger(self):
        """Triggers the event on runtime."""

        function self.payload_path

    def activate(self):
        """Activates and deploys the handler into the datapack."""

        self.handler(self)
        self.active = True

    def path(self, subpath: str) -> str:
        """Generates a function path inside the event working directory."""

        return f"{self.handler_dir}/{subpath}"

    def attach_payload(self, payload_ref: Callable):
        append function self.payload_path:
            payload_ref(*self.payload_params)

    @classmethod
    def _get_next_id(cls) -> int:
        index = cls.next_id
        cls.next_id += 1
        return index

@dataclass
class Listener:
    event: Event
    bypass_fork: bool = field(kw_only=True, default=False)

    def __call__(self, callback):
        self.event.activate()

        if isinstance(self.event, Event):
            self.event.attach_payload(callback, bypass_fork=self.bypass_fork)
        else:
            self.event.attach_payload(callback)
