from dataclasses import dataclass, field
from typing import ClassVar, Type, Callable, Any
from ./utils import decorator_factory, logger, pascal_to_snake_case, copy_reverse_clear
from ./config import Config
import inspect
import types

registered_events: dict[str, Type] = {}
deployed_events: list = []

@dataclass
class BuiltinEvent:
    event_id: ClassVar[str] = ''
    deployed: ClassVar[bool] = False
    path: ClassVar

    def __init_subclass__(cls, **kwargs):
        """Runs at the end of class definition."""

        # this is done so that '@supports_events'
        # is not necessary for event definitions 
        cls = supports_events(cls)

        cls._patch_class_defaults()
        cls._register_event()
        super().__init_subclass__(**kwargs)

    def __post_init__(self):
        """Runs after the event is deployed using the '.deploy()' method."""
        self._deploy_handler()

    @classmethod
    def deploy(cls):
        event_instance = cls()
        deployed_events.append(event_instance)
        cls.deployed = True

    def add_local_payload(self, payload: Callable, method_first_arg: Any = None):
        merge function_tag self.path['local_payload_fork'] {"values": [self.path['local_payload']]}
        append function self.path['local_payload']:
            if method_first_arg == None:
                payload()
            else:
                payload(method_first_arg)

    def add_global_payload(self, payload: Callable, method_first_arg: Any = None):
        append function self.path['global_payload']:
            if method_first_arg == None:
                payload()
            else:
                payload(method_first_arg)

    def generate_path(self, subpath: str):
        return f"{self.path['handler_dir']}/{subpath}"

    def trigger(self):
        execute function self.path['on_trigger']:
            function f"#{self.path['local_payload_fork']}"

    def _deploy_handler(self):
        if hasattr(self, '__event_init__') and callable(self.__event_init__):
            self.__event_init__()

    @classmethod
    def _patch_class_defaults(cls):
        cls.event_id = pascal_to_snake_case(cls.__name__)

        LOCAL_PATH = f"{Config.LOCAL_DIR}/builtin_event/{cls.event_id}"
        GLOBAL_PATH = f"{Config.GLOBAL_DIR}/builtin_event/{cls.event_id}"
        cls.path = {
            'on_trigger': f"{GLOBAL_PATH}/on_trigger",
            'handler_dir': f"{GLOBAL_PATH}/handler_dir",
            'local_payload': f"{LOCAL_PATH}/local_payload",
            'local_payload_fork': f"{GLOBAL_PATH}/local_payload_fork",
            'global_payload': f"{GLOBAL_PATH}/global_payload",
        }

    @classmethod
    def _register_event(cls):
        registered_events[cls.event_id] = cls

@dataclass
class ClassDefinitionMethodQueue:
    instance_listeners: ClassVar[list[Callable]] = []
    class_listeners: ClassVar[list[Callable]] = []

def _get_registered_event_class_by_id(event_id: str) -> Type[BuiltinEvent]:
    event_class = registered_events.get(event_id)

    if event_class == None:
        logger.error(f"Unknown event id '{event_id}'")
        exit()

    return event_class

def _get_deployed_event_by_id(event_id: str) -> BuiltinEvent:
    for event in deployed_events:
        if event.event_id == event_id:
            return event

def _initialize_listener(
    event_id: str,
    payload: Callable,
    method_first_arg: Any = None,
    is_global_payload: bool = False
):
    event_class = _get_registered_event_class_by_id(event_id)
    if not event_class.deployed:
        event_class.deploy()

    event = _get_deployed_event_by_id(event_id)

    if is_global_payload:
        event.add_global_payload(payload, method_first_arg=method_first_arg)
    else:
        event.add_local_payload(payload, method_first_arg=method_first_arg)

@decorator_factory
def event(func, *args, **kwargs):
    event_id = func.__name__
    func_is_method = '.' in func.__qualname__

    if func_is_method:
        ClassDefinitionMethodQueue.instance_listeners.append(func)
        return func

    event_class = _get_registered_event_class_by_id(event_id)
    if not event_class.deployed:
        event_class.deploy()

    event = _get_deployed_event_by_id(event_id)
    event.add_local_payload(func)

@decorator_factory
def class_event(func, *args, **kwargs):
    event_id = func.__name__

    ClassDefinitionMethodQueue.class_listeners.append(func)
    return func

def supports_events(cls):
    """Decorate a class to enable support for '@event_listener' on bound methods."""

    # def append_init(old_init: Callable, cls: Type, func: Callable, is_payload_class_method: bool):
    def prepend_init(cls: Type, method: Callable):
        old_init = cls.__init__

        def new_init(self, *args, **kwargs):
            event_id = method.__name__
            event_class = _get_registered_event_class_by_id(event_id)

            if not event_class.deployed:
                event_class.deploy()

            event = _get_deployed_event_by_id(event_id)

            event.add_local_payload(method, method_first_arg=self)
            # if is_payload_class_method:
            # event.add_local_payload(method, method_first_arg=cls)
            # else:
            #     event.add_local_payload(payload, method_first_arg=self)
            old_init(self, *args, **kwargs)

        cls.__init__ = new_init

    # TODO: this will be used for event definition behavior
    is_builtin_case = issubclass(cls, BuiltinEvent)

    instance_listeners = copy_reverse_clear(ClassDefinitionMethodQueue.instance_listeners)
    class_listeners = copy_reverse_clear(ClassDefinitionMethodQueue.class_listeners)
    
    for method in instance_listeners:
        new_method_name = f"_event_listener_{id(method)}"
        setattr(cls, new_method_name, method)
        prepend_init(cls, method)

        # if hasattr(method, '_is_instance_event_listener'):
            # cls.__init__ = modify_init(cls.__init__, cls, payload=method, is_payload_class_method=True)
        # elif hasattr(method, '_is_class_event_listener'):
            # cls.__init__ = modify_init(cls.__init__, cls, payload=method, is_payload_class_method=False)

    return cls
