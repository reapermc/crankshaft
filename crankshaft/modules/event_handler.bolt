from dataclasses import dataclass, field
from typing import ClassVar, Type, Callable, Any
from ./utils import decorator_factory, logger, pascal_to_snake_case
from ./config import Config
import inspect

@dataclass
class BuiltinEvent:
    event_id: ClassVar[str] = ''
    deployed: ClassVar[bool] = False
    path: ClassVar

    def __init_subclass__(cls, **kwargs):
        """Runs at the end of class definition."""

        # this is done so that '@supports_events'
        # is not necessary for event definitions 
        cls = supports_events(cls)

        cls._patch_class_defaults()
        cls._register_event()
        super().__init_subclass__(**kwargs)

    def __post_init__(self):
        """Runs after the event is deployed using the '.deploy()' method."""
        self._deploy_handler()

    @classmethod
    def deploy(cls):
        event_instance = cls()
        DEPLOYED_EVENTS.append(event_instance)
        cls.deployed = True

    def add_local_payload(self, payload: Callable, method_first_arg: Any = None):
        merge function_tag self.path['local_payload_fork'] {"values": [self.path['local_payload']]}
        append function self.path['local_payload']:
            if method_first_arg == None:
                payload()
            else:
                payload(method_first_arg)

    def add_global_payload(self, payload: Callable, method_first_arg: Any = None):
        append function temp:temp:
            if method_first_arg == None:
                payload()
            else:
                payload(method_first_arg)

    def generate_path(self, subpath: str):
        return f"{self.path['handler_dir']}/{subpath}"

    def trigger(self):
        execute function self.path['on_trigger']:
            function f"#{self.path['local_payload_fork']}"

    def _deploy_handler(self):
        if hasattr(self, '__event_init__') and callable(self.__event_init__):
            self.__event_init__()

    @classmethod
    def _patch_class_defaults(cls):
        cls.event_id = pascal_to_snake_case(cls.__name__)

        LOCAL_PATH = f"{Config.GLOBAL_DIR}/builtin_event/{cls.event_id}"
        GLOBAL_PATH = f"{Config.GLOBAL_DIR}/builtin_event/{cls.event_id}"
        cls.path = {
            'on_trigger': f"{GLOBAL_PATH}/on_trigger",
            'handler_dir': f"{GLOBAL_PATH}/handler_dir",
            'local_payload': f"{LOCAL_PATH}/local_payload",
            'local_payload_fork': f"{GLOBAL_PATH}/local_payload_fork",
            'global_payload': f"{GLOBAL_PATH}/global_payload",
        }

    @classmethod
    def _register_event(cls):
        REGISTERED_EVENTS[cls.event_id] = cls

REGISTERED_EVENTS: dict[str, Type[BuiltinEvent]] = {}
DEPLOYED_EVENTS: list[BuiltinEvent] = []

def _get_registered_event_class_by_id(event_id: str) -> Type[BuiltinEvent]:
    event_class = REGISTERED_EVENTS.get(event_id)

    if event_class == None:
        logger.error(f"Unknown event id '{event_id}'")
        exit()

    return event_class

def _get_deployed_event_by_id(event_id: str) -> BuiltinEvent:
    for event in DEPLOYED_EVENTS:
        if event.event_id == event_id:
            return event

def _initialize_listener(
    event_id: str,
    payload: Callable,
    method_first_arg: Any = None,
    is_global_payload: bool = False
):
    event_class = _get_registered_event_class_by_id(event_id)
    if not event_class.deployed:
        event_class.deploy()

    event = _get_deployed_event_by_id(event_id)

    if is_global_payload:
        event.add_global_payload(payload, method_first_arg=method_first_arg)
    else:
        event.add_local_payload(payload, method_first_arg=method_first_arg)

@decorator_factory
def event_listener(func, *args, **kwargs):
    """Decorate a function or method to turn it into an event listener."""
    event_id = func.__name__
    func_is_method = '.' in func.__qualname__

    if func_is_method:
        func._is_instance_event_listener = True
        return func

    _initialize_listener(event_id=event_id, payload=func)

@decorator_factory
def class_event_listener(func, *args, **kwargs):
    """Decorate a method to turn it into a class event listener."""
    event_id = func.__name__
    func._is_class_event_listener = True
    return func

def supports_events(cls):
    """Decorate a class to enable support for '@event_listener' on bound methods."""

    def modified_init(self, *args, **kwargs):
        for listener in instance_listeners:
            _initialize_listener(event_id=listener.__name__, payload=member, method_first_arg=self)
        original_init(self, *args, **kwargs)

    is_builtin_case = issubclass(cls, BuiltinEvent)

    instance_listeners = []
    class_listeners = []

    for _, member in inspect.getmembers(cls):
        if not inspect.isfunction(member):
            continue
        if hasattr(member, '_is_instance_event_listener'):
            instance_listeners.append(member)
        elif hasattr(member, '_is_class_event_listener'):
            class_listeners.append(member)

    if class_listeners:
        for listener in class_listeners:
            _initialize_listener(event_id=listener.__name__, payload=listener, method_first_arg=cls)
    if instance_listeners:
        # wraps '__init__' with code that wakes up
        # all instance event listeners on class init
        original_init = cls.__init__
        cls.__init__ = modified_init

    return cls
