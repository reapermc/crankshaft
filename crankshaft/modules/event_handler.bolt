from dataclasses import dataclass, field
from typing import ClassVar, Type, Callable, Any
from ./utils import decorator_factory, logger, pascal_to_snake_case, copy_reverse_clear, copy_clear
from ./config import Config
import inspect
import types

registered_events: dict[str, Type] = {}
deployed_events: list = []

@dataclass
class BuiltinEvent:
    event_id: ClassVar[str] = ''
    deployed: ClassVar[bool] = False
    path: ClassVar

    def __init_subclass__(cls, **kwargs):
        """Runs at the end of class definition."""

        # this is done so that '@supports_events'
        # is not necessary for event definitions 
        cls = supports_events(cls)

        cls._patch_class_defaults()
        cls._register_event()
        super().__init_subclass__(**kwargs)

    def __post_init__(self):
        """Runs after the event is deployed using the '.deploy()' method."""
        self._deploy_handler()

    @classmethod
    def deploy(cls):
        event_instance = cls()
        deployed_events.append(event_instance)
        cls.deployed = True

    def add_local_payload(self, func: Callable, method_first_arg: Any = None):
        merge function_tag self.path['local_payload_fork'] {"values": [self.path['local_payload']]}
        append function self.path['local_payload']:
            if method_first_arg == None:
                func()
            else:
                func(method_first_arg)

    def add_global_payload(self, func: Callable, method_first_arg: Any = None):
        append function self.path['global_payload']:
            if method_first_arg == None:
                func()
            else:
                func(method_first_arg)

    def generate_path(self, subpath: str):
        return f"{self.path['handler_dir']}/{subpath}"

    def trigger(self):
        execute function self.path['on_trigger']:
            function f"#{self.path['local_payload_fork']}"

    def _deploy_handler(self):
        if hasattr(self, '__event_init__') and callable(self.__event_init__):
            self.__event_init__()

    @classmethod
    def _patch_class_defaults(cls):
        cls.event_id = pascal_to_snake_case(cls.__name__)

        LOCAL_PATH = f"{Config.LOCAL_DIR}/builtin_event/{cls.event_id}"
        GLOBAL_PATH = f"{Config.GLOBAL_DIR}/builtin_event/{cls.event_id}"
        cls.path = {
            'on_trigger': f"{GLOBAL_PATH}/on_trigger",
            'handler_dir': f"{GLOBAL_PATH}/handler_dir",
            'local_payload': f"{LOCAL_PATH}/local_payload",
            'local_payload_fork': f"{GLOBAL_PATH}/local_payload_fork",
            'global_payload': f"{GLOBAL_PATH}/global_payload",
        }

    @classmethod
    def _register_event(cls):
        registered_events[cls.event_id] = cls

@dataclass
class ClassDefinitionMethodQueue:
    instance_listeners: ClassVar[list[Callable]] = []
    class_listeners: ClassVar[list[Callable]] = []
    lazy_class_listeners: ClassVar[list[Callable]] = []

def _get_registered_event_class_by_id(event_id: str) -> Type[BuiltinEvent]:
    event_class = registered_events.get(event_id)

    if event_class == None:
        logger.error(f"Unknown event id '{event_id}'")
        exit()

    return event_class

def _get_deployed_event_by_id(event_id: str) -> BuiltinEvent:
    for event in deployed_events:
        if event.event_id == event_id:
            return event

def _initialize_listener(
    event_id: str,
    payload: Callable,
    method_first_arg: Any = None,
    is_global_payload: bool = False
):
    event_class = _get_registered_event_class_by_id(event_id)
    if not event_class.deployed:
        event_class.deploy()

    event = _get_deployed_event_by_id(event_id)

    if is_global_payload:
        event.add_global_payload(payload, method_first_arg=method_first_arg)
    else:
        event.add_local_payload(payload, method_first_arg=method_first_arg)

@decorator_factory
def event(func, *args, **kwargs):
    event_id = func.__name__
    func_is_method = '.' in func.__qualname__

    if func_is_method:
        ClassDefinitionMethodQueue.instance_listeners.append(func)
        return func

    event_class = _get_registered_event_class_by_id(event_id)
    if not event_class.deployed:
        event_class.deploy()

    event = _get_deployed_event_by_id(event_id)
    event.add_local_payload(func)
    return func

@decorator_factory
def class_event(func, *args, **kwargs):
    event_id = func.__name__

    ClassDefinitionMethodQueue.class_listeners.append(func)
    return func

@decorator_factory
def lazy_class_event(func, *args, **kwargs):
    event_id = func.__name__

    ClassDefinitionMethodQueue.lazy_class_listeners.append(func)
    return func

def supports_events(cls):
    """Decorate a class to enable support for '@event_listener' on bound methods."""

    def run_on_class_init(cls: Type, method: Callable):
        old_init = cls.__init__

        def new_init(self, *args, **kwargs):
            event_id = method.__name__
            event_class = _get_registered_event_class_by_id(event_id)

            if not event_class.deployed:
                event_class.deploy()

            event = _get_deployed_event_by_id(event_id)

            event.add_local_payload(method, method_first_arg=self)
            old_init(self, *args, **kwargs)

        cls.__init__ = new_init

    def run_on_class_definition(cls: Type, method: Callable):
        event_id = method.__name__
        event_class = _get_registered_event_class_by_id(event_id)

        if not event_class.deployed:
            event_class.deploy()

        event = _get_deployed_event_by_id(event_id)
        event.add_local_payload(method, method_first_arg=cls)

    def run_on_class_init_once(cls: Type, method: Callable):
        old_init = cls.__init__

        def new_init(self, *args, **kwargs):
            if cls._crankshaft_lazy_class_listener_count == 0:
                return

            event_id = method.__name__
            event_class = _get_registered_event_class_by_id(event_id)

            if not event_class.deployed:
                event_class.deploy()

            event = _get_deployed_event_by_id(event_id)

            event.add_local_payload(method, method_first_arg=self)
            cls._crankshaft_lazy_class_listener_count -= 1

            old_init(self, *args, **kwargs)

        cls.__init__ = new_init

    # TODO: this will be used for event definition behavior
    is_builtin_case = issubclass(cls, BuiltinEvent)

    instance_listeners = copy_reverse_clear(ClassDefinitionMethodQueue.instance_listeners)
    class_listeners = copy_clear(ClassDefinitionMethodQueue.class_listeners)
    lazy_class_listeners = copy_reverse_clear(ClassDefinitionMethodQueue.lazy_class_listeners)

    for method in instance_listeners:
        # setattr(cls, f"_crankshaft_event_listener_{id(method)}", method)
        run_on_class_init(cls, method)

    for method in class_listeners:
        run_on_class_definition(cls, method)

    if lazy_class_listeners and not hasattr(cls, '_crankshaft_lazy_class_listeners'):
        cls._crankshaft_lazy_class_listener_count = len(lazy_class_listeners)

    for method in lazy_class_listeners:
        # setattr(cls, f"_crankshaft_lazy_class_listener_{id(method)}", method)
        run_on_class_init_once(cls, method)

    return cls
