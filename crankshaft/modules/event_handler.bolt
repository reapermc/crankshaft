from wicked_expressions:api import copy_args, ExprOnly, ScoreSource, DataSource, Scoreboard, Data
from dataclasses import dataclass, field
from typing import ClassVar, Type, Callable, Any
from ./utils import decorator_factory, logger, pascal_to_snake_case, copy_reverse_clear, copy_clear
from ./config import Config
import inspect

registered_events: dict[str, Type] = {}
deployed_events: list = []

@dataclass
class BuiltinEvent:
    deployed: ClassVar[bool] = False

    def __init_subclass__(cls, **kwargs):
        """Runs at the end of class definition."""

        cls._patch_class_defaults()
        cls._register_event()

        # this is done so that '@supports_events'
        # is not necessary for event definitions
        cls = supports_events(cls)

        super().__init_subclass__(**kwargs)

    def __post_init__(self):
        """Runs after the event is deployed using the '.deploy()' method."""

        if hasattr(self, '__event_init__') and callable(self.__event_init__):
            function self._path['event_init']:
                self.__event_init__()

        # TODO: cleanup builtin event handling
        # as this is not necessary
        # -=-=-=-=-=-=-=-=-=-=-=-=-
        # for dependency_class in self.dependencies:
        #     print(dependency_class.deployed)
        #     if not dependency_class.deployed:
        #         dependency_class.deploy()
            
        #     dependency = _get_deployed_event_by_id(dependency_class.event_id)

    @classmethod
    def deploy(cls):
        event_instance = cls()
        deployed_events.append(event_instance)
        cls.deployed = True

    def add_local_payload(self, func: Callable, method_first_arg: Any = None):
        merge function_tag self._path['local_payload_fork'] {"values": [self._path['local_payload']]}
        append function self._path['local_payload']:
            # is_method = method_first_arg != None
            # self._validate_trigger_output_args(func, is_method)

            # func = self._decorate_payload_copy_args(func)

            if method_first_arg == None:
                func(*self.trigger_args, **self.trigger_kwargs)
            else:
                func(method_first_arg, *self.trigger_args, **self.trigger_kwargs)

    def _decorate_payload_copy_args(self, func: Callable) -> Callable:
        """This ensures args passed thru 'self.trigger()' are safe copies."""
        params = inspect.signature(func).parameters
        param_list = []
        type_annotations = {}

        for param in params:
            param_list.append(param)

        for arg in self.trigger_args:
            param = param_list[0]
            del param_list[0]

            if isinstance(arg, ScoreSource):
                type_annotations[param] = ExprOnly(Scoreboard)
            elif isinstance(arg, DataSource):
                type_annotations[param] = ExprOnly(Data)

        for kwarg_value in self.trigger_kwargs.values():
            param = param_list[0]
            del param_list[0]

            if isinstance(kwarg_value, ScoreSource):
                type_annotations[param] = ExprOnly(Scoreboard)
            elif isinstance(kwarg_value, DataSource):
                type_annotations[param] = ExprOnly(Data)

        return copy_args(**type_annotations)(func)

    @classmethod
    def queue_potential_subevent(cls, subevent_class: Type):
        append function cls._path['subevent_runner']:
            function subevent_class._generate_subevent_entrypoint(cls)

    @classmethod
    def _generate_subevent_entrypoint(cls, dependency_event_class) -> str:
        subevent_id = pascal_to_snake_case(cls.__name__)
        dependency_event_id = dependency_event_class.event_id
        return f"{Config.GLOBAL_DIR}/builtin_event/{subevent_id}/subevent_entrypoint/{dependency_event_id}"

    # @classmethod
    # def add_dependency(cls, event_class):
    #     cls.dependencies.append(event_class)

    def generate_path(self, subpath: str):
        return f"{self._path['handler']}/{subpath}"

    def trigger(self, *args, **kwargs):
        self.trigger_args = [*args] 
        self.trigger_kwargs = {**kwargs}

        execute function self._path['on_trigger']:
            function f"#{self._path['local_payload_fork']}"
            function self._path['subevent_runner']

    @classmethod
    def _patch_class_defaults(cls):
        cls.event_id = pascal_to_snake_case(cls.__name__)

        LOCAL_PATH = f"{Config.LOCAL_DIR}/builtin_event/{cls.event_id}"
        GLOBAL_PATH = f"{Config.GLOBAL_DIR}/builtin_event/{cls.event_id}"

        cls.trigger_args = []
        cls.trigger_kwargs = {}
        cls._path = {
            'on_trigger': f"{GLOBAL_PATH}/on_trigger",
            'handler': f"{GLOBAL_PATH}/handler",
            'event_init': f"{GLOBAL_PATH}/handler/__event_init__",
            'local_payload': f"{LOCAL_PATH}/local_payload",
            'local_payload_fork': f"{GLOBAL_PATH}/local_payload_fork",
            'subevent_runner': f"{GLOBAL_PATH}/subevent_runner",
        }
        cls.SCOREBOARD_ROOT = f"{Config.SCOREBOARD_ROOT}.builtin_event.{cls.event_id}"
        # cls.dependencies = []

    @classmethod
    def _register_event(cls):
        registered_events[cls.event_id] = cls

@dataclass
class ClassDefinitionMethodQueue:
    instance_listeners: ClassVar[list[Callable]] = []
    class_listeners: ClassVar[list[Callable]] = []
    lazy_class_listeners: ClassVar[list[Callable]] = []

def _get_registered_event_class_by_id(event_id: str) -> Type[BuiltinEvent]:
    event_class = registered_events.get(event_id)

    if event_class == None:
        logger.error(f"Unknown event id '{event_id}'")
        exit()

    return event_class

def _get_deployed_event_by_id(event_id: str) -> BuiltinEvent:
    for event in deployed_events:
        if event.event_id == event_id:
            return event

@decorator_factory
def event(func, *args, **kwargs):
    event_id = func.__name__
    func_is_method = '.' in func.__qualname__

    if func_is_method:
        ClassDefinitionMethodQueue.instance_listeners.append(func)
        return func

    event_class = _get_registered_event_class_by_id(event_id)
    if not event_class.deployed:
        event_class.deploy()

    event = _get_deployed_event_by_id(event_id)
    event.add_local_payload(func)
    return func

@decorator_factory
def class_event(func, *args, **kwargs):
    event_id = func.__name__

    ClassDefinitionMethodQueue.class_listeners.append(func)
    return func

@decorator_factory
def lazy_class_event(func, *args, **kwargs):
    event_id = func.__name__

    ClassDefinitionMethodQueue.lazy_class_listeners.append(func)
    return func

def supports_events(cls):
    """Decorate a class to enable support for '@event_listener' on bound methods."""

    def run_on_class_init(
        cls: Type,
        method: Callable,
        builtin: bool = False,
    ):
        old_init = cls.__init__

        def new_init(self, *args, **kwargs):
            event_id = method.__name__
            event_class = _get_registered_event_class_by_id(event_id)

            if not event_class.deployed:
                event_class.deploy()

            event = _get_deployed_event_by_id(event_id)

            if builtin:
                function self._generate_subevent_entrypoint(event.__class__):
                    method(self)
            else:
                event.add_local_payload(method, method_first_arg=self)

            old_init(self, *args, **kwargs)

        cls.__init__ = new_init

    def run_on_class_definition(cls: Type, method: Callable):
        event_id = method.__name__
        event_class = _get_registered_event_class_by_id(event_id)

        if not event_class.deployed:
            event_class.deploy()

        event = _get_deployed_event_by_id(event_id)
        event.add_local_payload(method, method_first_arg=cls)

    def run_on_class_init_once(cls: Type, method: Callable):
        old_init = cls.__init__

        def new_init(self, *args, **kwargs):
            if cls._crankshaft_lazy_class_listener_count == 0:
                return

            event_id = method.__name__
            event_class = _get_registered_event_class_by_id(event_id)

            if not event_class.deployed:
                event_class.deploy()

            event = _get_deployed_event_by_id(event_id)

            event.add_local_payload(method, method_first_arg=self)
            cls._crankshaft_lazy_class_listener_count -= 1

            old_init(self, *args, **kwargs)

        cls.__init__ = new_init

    is_builtin_definition_case = issubclass(cls, BuiltinEvent)

    instance_listeners = copy_reverse_clear(ClassDefinitionMethodQueue.instance_listeners)
    class_listeners = copy_clear(ClassDefinitionMethodQueue.class_listeners)
    lazy_class_listeners = copy_reverse_clear(ClassDefinitionMethodQueue.lazy_class_listeners)

    if is_builtin_definition_case:
        for method in instance_listeners:
            dependency_event_id = method.__name__
            dependency_event_class = _get_registered_event_class_by_id(dependency_event_id)

            run_on_class_init(
                cls,
                method,
                builtin=True,
            )

            dependency_event_class.queue_potential_subevent(subevent_class=cls)
            # cls.add_dependency(dependency_event_class)

        return cls

    for method in instance_listeners:
        run_on_class_init(cls, method)

    for method in class_listeners:
        run_on_class_definition(cls, method)

    if lazy_class_listeners and not hasattr(cls, '_crankshaft_lazy_class_listeners'):
        cls._crankshaft_lazy_class_listener_count = len(lazy_class_listeners)
    for method in lazy_class_listeners:
        run_on_class_init_once(cls, method)

    return cls
