from wicked_expressions:api import Scoreboard
from lightning_rod:api import revoke_advancement, add_tag, remove_tag
from ./event_handler/event_definition import BuiltinEvent
from ./event_handler/listeners import dependency, early_dependency
from ./flag_handler import flag
from ./cwd import get_cwd

class Load(BuiltinEvent):
    def __event_init__(self):
        merge function_tag minecraft:load {"values": [get_cwd()]}
        self.trigger()

class Tick(BuiltinEvent):
    def __event_init__(self):
        merge function_tag minecraft:tick {"values": [get_cwd()]}
        self.trigger()

class PlayerTick(BuiltinEvent):
    @dependency
    def tick(self):
        as @a at @s:
            self.trigger()

class PlayerJoin(BuiltinEvent):
    @dependency
    def player_tick(self):
        join_tracker = Scoreboard(f"{self.SCOREBOARD_ROOT}.join_tracker", 'custom:leave_game')['@s']

        # if join_tracker >= 1:
        if score var join_tracker matches 1..:
            join_tracker = 0
            self.trigger()

class PlayerLoad(BuiltinEvent):
    @dependency
    def load(self):
        as @a at @s:
            self.trigger()

    @dependency
    def player_join(self):
        self.trigger()

class PlayerChargeBow(BuiltinEvent):
    def __event_init__(self):
        self.charge_time_tracker = Scoreboard(f"{self.SCOREBOARD_ROOT}.charge_time")['@s']
        self.charging_tag = f"{self.TAG_ROOT}.charging"
        advancement_path = f"{get_cwd()}/on_charge"
        advancement_reward_path = f"{get_cwd()}/reward"
        advancement advancement_path {
            "criteria": {
                "requirement": {
                    "trigger": "minecraft:using_item",
                    "conditions": {
                        "item": {
                            "items": [
                                "minecraft:bow"
                            ]
                        }
                    }
                }
            },
            "rewards": {
                "function": advancement_reward_path
            }
        }

        function advancement_reward_path:
            add_tag(self.charging_tag)
            self.charge_time_tracker += 1
            self.trigger(charge_time=self.charge_time_tracker)
            revoke_advancement(advancement_path)

    @dependency
    def player_tick(self):
        if entity @s[tag=!self.charging_tag]:
            self.charge_time_tracker = 0
        remove_tag(self.charging_tag)

class PlayerChargeBowStart(BuiltinEvent):
    @early_dependency
    def player_charge_bow(self, charge_time):
        # if charge_time == 1:
        if score var charge_time matches 1:
            self.trigger()

class PlayerChargeBowEnd(BuiltinEvent):
    def __event_init__(self):
        self.charge_time_tracker = Scoreboard(f"{self.SCOREBOARD_ROOT}.charge_time")['@s']
        self.charging_tag = f"{self.TAG_ROOT}.charging"
        self.temp = f"{self.TAG_ROOT}.temp"

    @dependency
    def player_charge_bow(self, charge_time):
        self.charge_time_tracker = charge_time
        add_tag(self.charging_tag)
        add_tag(self.temp)

    @dependency
    def player_tick(self):
        if entity @s[tag=!self.charging_tag]:
            if entity @s[tag=self.temp]:
                remove_tag(self.temp)
                self.trigger(charge_time=self.charge_time_tracker)
        remove_tag(self.charging_tag)

class PlayerShotBow(BuiltinEvent):
    def __event_init__(self):
        self.charge_time_tracker = Scoreboard(f"{self.SCOREBOARD_ROOT}.charge_time")['@s']
        self.use_item_tracker = Scoreboard(f"{self.SCOREBOARD_ROOT}.shot_bow", 'used:bow')['@s']

    @dependency
    def player_charge_bow(self, charge_time):
        self.charge_time_tracker = charge_time

    @dependency
    def player_tick(self):
        # if self.use_item_tracker >= 1:
        if score var self.use_item_tracker matches 1..:
            self.use_item_tracker = 0
            self.trigger(charge_time=self.charge_time_tracker)

class PlayerUseCoas(BuiltinEvent):
    @dependency
    def player_tick(self):
        use_tracker = Scoreboard(f"{self.SCOREBOARD_ROOT}.use_tracker", 'used:carrot_on_a_stick')['@s']

        # if death_tracker >= 1:
        if score var use_tracker matches 1..:
            use_tracker = 0
            self.trigger()

class PlayerUseWfoas(BuiltinEvent):
    @dependency
    def player_tick(self):
        use_tracker = Scoreboard(f"{self.SCOREBOARD_ROOT}.use_tracker", 'used:warped_fungus_on_a_stick')['@s']

        # if death_tracker >= 1:
        if score var use_tracker matches 1..:
            use_tracker = 0
            self.trigger()

class PlayerJump(BuiltinEvent):
    @dependency
    def player_tick(self):
        jump_tracker = Scoreboard(f"{self.SCOREBOARD_ROOT}.jump_tracker", 'custom:jump')['@s']

        # if jump_tracker >= 1:
        if score var jump_tracker matches 1..:
            jump_tracker = 0
            self.trigger()

class PlayerLand(BuiltinEvent):
    @dependency
    def player_tick(self):
        airborne_tag = f"{self.TAG_ROOT}.airborne"

        if flag.is_airborne == True:
            add_tag(airborne_tag)
        if flag.is_airborne == False:
            if entity @s[tag=airborne_tag]:
                remove_tag(airborne_tag)
                self.trigger()

class PlayerDie(BuiltinEvent):
    @dependency
    def player_tick(self):
        death_tracker = Scoreboard(f"{self.SCOREBOARD_ROOT}.death_tracker", 'deathCount')['@s']

        # if death_tracker >= 1:
        if score var death_tracker matches 1..:
            death_tracker = 0
            self.trigger()

class PlayerRespawn(BuiltinEvent):
    @dependency
    def tick(self):
        death_tracker = Scoreboard(f"{self.SCOREBOARD_ROOT}.death_tracker", 'deathCount')['@s']

        # unlike '@a', '@e[type=player]'
        # only targets alive players
        as @e[type=player] at @s:
            # if death_tracker >= 1:
            if score var death_tracker matches 1..:
                death_tracker = 0
                self.trigger()


